## 回调
我们希望了解脚本何时加载完成，以使用其中的新函数和变量。
### 回调函数什么时候执行？

### 嵌套回调
### 链式回调
### 回调地狱真正问题所在
手工硬编码（即使包含了硬编码的出错处理）。
一旦指定（也就是预先计划）了所有的可能事件和路径，代码就变得非常复杂，以至于无法维护和更新。这才是回调地狱的真正问题所在。

### 回调缺点
#### 缺乏顺序性。顺序的人脑计划和回调驱动的异步JavaScript代码之间不匹配
大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的、顺序的，这使得正确推导这样的代码难度很大。难于理解的代码是坏代码，会导致坏bug。我们需要一种更同步、更顺序、更阻塞的方式来表达异步，就像我们的大脑一样。
#### 缺乏可信任性。对于被传递给你无法信任的工具的每个回调，你都将不得不创建大量的混乱逻辑。
回调会受到控制反转的影响，因为回调暗中把控制权交给第三方（通常不受你控制的第三方工具）来调用你代码中的continuation。这种控制转移导致一系列麻烦的信任问题，比如回调被调用的次数是否会超出预期。可以发明一些特定逻辑来解决这些信任问题，但是其难度高于应有的水平，可能会产生更笨重、更难维护的代码，并且缺少足够的保护，其中的损害要直到你受到bug的影响才会被发现。

我们需要一个通用的方案来解决这些信任问题。不管我们创建多少回调，这一方案都应可以复用，并且没有重复代码的开销。
### 可能出错的情况
- 调用回调过早（在追踪之前）
- 调用回调过晚（或没有调用）
- 调用回调的次数太少或太多
- 没有把所需的环境/参数成功传给回调函数
- 吞掉可能出现的错误异常
## Promise
使用**分离回调设计**。

### `Promise`类有5种静态方法
1. Promise.all(promises) —— 等待所有 promise 都 resolve 时，返回存放它们结果的数组。如果给定的任意一个 promise 为 reject，那么它就会变成 Promise.all 的 error，所有其他 promise 的结果都会被忽略。
2. Promise.allSettled(promises)（ES2020 新增方法）—— 等待所有 promise 都 settle 时，并以包含以下内容的对象数组的形式返回它们的结果：
status: "fulfilled" 或 "rejected"
value（如果 fulfilled）或 reason（如果 rejected）。
3. Promise.race(promises) —— 等待第一个 settle 的 promise，并将其 result/error 作为结果。
4. Promise.resolve(value) —— 使用给定 value 创建一个 resolved 的 promise。
5. Promise.reject(error) —— 使用给定 error 创建一个 rejected 的 promise。
这五个方法中，Promise.all 可能是在实战中使用最多的。